// Generated by CoffeeScript 1.6.3
(function() {
  var ActiveBallState, BALL_ANIMATION_FPS, BALL_ANIMATION_FRAME_COUNT, BALL_COLORS, BALL_COUNT_AT_START, BALL_COUNT_PER_MOVE, BALL_SIZE, Ball, BallGrid, CELL_SIZE, COL_COUNT, Cell, GameState, LINE_COUNT, PREPARED_BALL_SCALE_FACTOR, PreparedBallState, UsualBallState, extractRandom;

  CELL_SIZE = 52;

  BALL_SIZE = 48;

  BALL_ANIMATION_FRAME_COUNT = 8;

  BALL_ANIMATION_FPS = 10;

  COL_COUNT = 9;

  LINE_COUNT = 9;

  BALL_COUNT_AT_START = 5;

  BALL_COUNT_PER_MOVE = 3;

  PREPARED_BALL_SCALE_FACTOR = 0.5;

  BALL_COLORS = ['blue', 'green', 'pink', 'red', 'teal', 'yellow'];

  PreparedBallState = gamvas.ActorState.extend({
    enter: function() {
      this.actor.setAnimation('usual');
      return this.actor.setScale(PREPARED_BALL_SCALE_FACTOR);
    },
    leave: function() {
      console.log("Leaving prepared ball state");
      return this.actor.setScale(1);
    }
  });

  ActiveBallState = gamvas.ActorState.extend({
    enter: function() {
      return this.actor.setAnimation('active');
    }
  });

  UsualBallState = gamvas.ActorState.extend({
    enter: function() {
      return this.actor.setAnimation('usual');
    }
  });

  Ball = gamvas.Actor.extend({
    create: function(name, x, y, color, gridX, gridY) {
      var imageName, resource;
      this.color = color;
      this.gridX = gridX;
      this.gridY = gridY;
      this._super(name, x, y);
      imageName = this.color + '.png';
      resource = gamvas.state.getCurrentState().resource;
      this.addAnimation(new gamvas.Animation('active', resource.getImage(imageName), BALL_SIZE, BALL_SIZE, BALL_ANIMATION_FRAME_COUNT, BALL_ANIMATION_FPS));
      this.addAnimation(new gamvas.Animation('usual', resource.getImage(imageName), BALL_SIZE, BALL_SIZE, 1));
      this.addState(new ActiveBallState('active'));
      this.addState(new PreparedBallState('prepared'));
      return this.addState(new UsualBallState('usual'), true);
    }
  });

  Cell = gamvas.Actor.extend({
    create: function(name, x, y) {
      this._super(name, x, y);
      return this.setFile(gamvas.state.getCurrentState().resource.getImage('cell.png'));
    }
  });

  BallGrid = (function() {
    BallGrid.prototype.LINE_DIRECTIONS = [[-1, 0], [-1, -1], [0, -1], [1, -1]];

    BallGrid.prototype.MIN_LINE_LENGTH = 5;

    BallGrid.prototype.REACHABLE_CELLS = [[-1, 0], [0, -1], [1, 0], [0, 1]];

    function BallGrid(width, height, parent) {
      this.width = width;
      this.height = height;
      this.parent = parent;
      this.container = this.getGrid(this.width);
      this.initCells();
    }

    BallGrid.prototype.initCells = function() {
      var cell, i, j, x, y, _i, _ref, _results;
      this.cells = this.getGrid(this.width);
      _results = [];
      for (i = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _ref2, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            _ref2 = this.parent.getCellScreenPos(i, j), x = _ref2[0], y = _ref2[1];
            cell = new Cell(false, x, y);
            this.cells[i][j] = cell;
            _results1.push(this.parent.addActor(cell));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    BallGrid.prototype.getGrid = function(width) {
      var i, res, _i;
      res = [];
      for (i = _i = 0; 0 <= width ? _i < width : _i > width; i = 0 <= width ? ++_i : --_i) {
        res.push([]);
      }
      return res;
    };

    BallGrid.prototype.add = function(x, y, ball) {
      /*
      Adds ball to a grid and check lines removal
      Returns true if any line was removed
      */

      this.container[x][y] = ball;
      return this.checkLinesRemovalInPosition(x, y);
    };

    BallGrid.prototype.remove = function(x, y) {
      return this.container[x][y] = null;
    };

    BallGrid.prototype.get = function(x, y) {
      return this.container[x][y];
    };

    BallGrid.prototype.getFreePositions = function() {
      var i, j, res, _i, _j, _ref, _ref1;
      res = [];
      for (i = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          if (!this.container[i][j]) {
            res.push([i, j]);
          }
        }
      }
      return res;
    };

    BallGrid.prototype.checkLinesRemovalInPosition = function(x, y) {
      /*
      Checks lines for all possible directions
      Returns true if any line was removed
      */

      var color, dirCount, dx, dy, line, linesToRemove, oppositeDirCount, startX, startY, totalCount, _i, _j, _len, _len1, _ref, _ref1;
      color = this.container[x][y].color;
      linesToRemove = [];
      _ref = this.LINE_DIRECTIONS;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], dx = _ref1[0], dy = _ref1[1];
        dirCount = this.getMaxBallCount(x, y, dx, dy, color);
        oppositeDirCount = this.getMaxBallCount(x, y, -dx, -dy, color);
        totalCount = dirCount + oppositeDirCount + 1;
        if (totalCount < this.MIN_LINE_LENGTH) {
          continue;
        }
        startX = x + dx * dirCount;
        startY = y + dy * dirCount;
        linesToRemove.push([startX, startY, -dx, -dy, totalCount]);
      }
      if (!linesToRemove.length) {
        return false;
      }
      for (_j = 0, _len1 = linesToRemove.length; _j < _len1; _j++) {
        line = linesToRemove[_j];
        this.removeLine.apply(this, line);
      }
      return true;
    };

    BallGrid.prototype.getMaxBallCount = function(x, y, dx, dy, neededColor) {
      var ball, res;
      res = 0;
      x += dx;
      y += dy;
      while ((0 <= x && x < this.width) && (0 <= y && y < this.height) && (ball = this.container[x][y]) && (ball.color === neededColor)) {
        res++;
        x += dx;
        y += dy;
      }
      return res;
    };

    BallGrid.prototype.removeLine = function(startX, startY, dx, dy, count) {
      var curX, curY, i, _i, _results;
      _results = [];
      for (i = _i = 1; 1 <= count ? _i <= count : _i >= count; i = 1 <= count ? ++_i : --_i) {
        if (typeof curX !== "undefined" && curX !== null) {
          curX += dx;
        } else {
          curX = startX;
        }
        if (typeof curY !== "undefined" && curY !== null) {
          curY += dy;
        } else {
          curY = startY;
        }
        _results.push(this.parent.removeBall(curX, curY));
      }
      return _results;
    };

    BallGrid.prototype.getReachGrid = function(x, y) {
      var cellQueue, dx, dy, newX, newY, nextStepCount, res, _i, _len, _ref, _ref1, _ref2;
      res = this.getGrid(this.width);
      res[x][y] = 0;
      cellQueue = [[x, y]];
      while (cellQueue.length) {
        _ref = cellQueue.shift(), x = _ref[0], y = _ref[1];
        nextStepCount = res[x][y] + 1;
        _ref1 = this.REACHABLE_CELLS;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], dx = _ref2[0], dy = _ref2[1];
          newX = x + dx;
          newY = y + dy;
          if (!((0 <= newX && newX < this.width)) || !((0 <= newY && newY < this.height))) {
            continue;
          }
          if (res[newX][newY] !== void 0) {
            continue;
          }
          if (this.container[newX][newY]) {
            continue;
          }
          res[newX][newY] = nextStepCount;
          cellQueue.push([newX, newY]);
        }
      }
      return res;
    };

    BallGrid.prototype.canReach = function(startX, startY, endX, endY) {
      var grid;
      grid = this.getReachGrid(startX, startY);
      return grid[endX][endY] != null;
    };

    return BallGrid;

  })();

  extractRandom = function(array) {
    var index, res, _ref;
    index = Math.floor(Math.random() * array.length);
    res = array[index];
    [].splice.apply(array, [index, index - index + 1].concat(_ref = [])), _ref;
    return res;
  };

  GameState = gamvas.State.extend({
    init: function() {
      this.gridPosClicks = [];
      this.preparedBalls = [];
      this.grid = new BallGrid(COL_COUNT, LINE_COUNT, this);
      this.addBallsToGrid(this.createRandomBalls(BALL_COUNT_AT_START));
      this.prepareBallsToAdd();
      return this.camera.setPosition(CELL_SIZE * COL_COUNT / 2, CELL_SIZE * LINE_COUNT / 2);
    },
    createRandomBalls: function(num) {
      var color, colorIndex, freePositions, gridX, gridY, i, res, _i, _ref;
      res = [];
      freePositions = this.grid.getFreePositions();
      for (i = _i = 1; 1 <= num ? _i <= num : _i >= num; i = 1 <= num ? ++_i : --_i) {
        _ref = extractRandom(freePositions), gridX = _ref[0], gridY = _ref[1];
        colorIndex = Math.floor(Math.random() * BALL_COLORS.length);
        color = BALL_COLORS[colorIndex];
        res.push(this.createBall(gridX, gridY, color));
      }
      return res;
    },
    createBall: function(gridX, gridY, color) {
      return new Ball(false, 0, 0, color, gridX, gridY);
    },
    addBallsToGrid: function(balls) {
      var ball, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = balls.length; _i < _len; _i++) {
        ball = balls[_i];
        _results.push(this.addBallToGrid(ball));
      }
      return _results;
    },
    addBallToGrid: function(ball) {
      this.updateBallScreenPos(ball);
      this.addActor(ball);
      return this.grid.add(ball.gridX, ball.gridY, ball);
    },
    prepareBallsToAdd: function() {
      var ball, newBalls, _i, _len, _results;
      newBalls = this.createRandomBalls(BALL_COUNT_PER_MOVE);
      _results = [];
      for (_i = 0, _len = newBalls.length; _i < _len; _i++) {
        ball = newBalls[_i];
        ball.setState('prepared');
        this.updateBallScreenPos(ball);
        this.addActor(ball);
        _results.push(this.preparedBalls.push(ball));
      }
      return _results;
    },
    removeBall: function(x, y) {
      var ball;
      if (!(ball = this.grid.get(x, y))) {
        return;
      }
      this.removeActor(ball);
      return this.grid.remove(x, y);
    },
    draw: function() {
      var ball, lineRemoved, pos, x, y, _i, _len, _ref;
      _ref = this.gridPosClicks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pos = _ref[_i];
        x = pos[0], y = pos[1];
        if (ball = this.grid.get(x, y)) {
          this.setActiveBall(ball);
        } else if (this.activeBall) {
          if (!this.grid.canReach(this.activeBall.gridX, this.activeBall.gridY, x, y)) {
            continue;
          }
          lineRemoved = this.setBallPos(this.activeBall, x, y);
          this.setActiveBall(null);
          if (lineRemoved) {
            continue;
          }
          this.addPreparedBalls();
          this.prepareBallsToAdd();
        }
      }
      return this.gridPosClicks = [];
    },
    replaceBalls: function(ballsToReplace, fixedBalls) {
      var ball, curX, curY, freePositions, index, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      freePositions = this.grid.getFreePositions();
      for (_i = 0, _len = fixedBalls.length; _i < _len; _i++) {
        ball = fixedBalls[_i];
        for (index = _j = 0, _len1 = freePositions.length; _j < _len1; index = ++_j) {
          _ref = freePositions[index], curX = _ref[0], curY = _ref[1];
          if (curX === ball.gridX && curY === ball.gridY) {
            break;
          }
        }
        [].splice.apply(freePositions, [index, index - index + 1].concat(_ref1 = [])), _ref1;
      }
      _results = [];
      for (_k = 0, _len2 = ballsToReplace.length; _k < _len2; _k++) {
        ball = ballsToReplace[_k];
        _ref2 = extractRandom(freePositions), ball.gridX = _ref2[0], ball.gridY = _ref2[1];
        _results.push(this.updateBallScreenPos(ball));
      }
      return _results;
    },
    addPreparedBalls: function() {
      var ball, ballsToReplace, fixedBalls, _i, _len, _ref;
      ballsToReplace = [];
      fixedBalls = [];
      _ref = this.preparedBalls;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ball = _ref[_i];
        ball.setState('usual');
        if (this.grid.get(ball.gridX, ball.gridY)) {
          ballsToReplace.push(ball);
        } else {
          fixedBalls.push(ball);
        }
      }
      if (ballsToReplace) {
        this.replaceBalls(ballsToReplace, fixedBalls);
      }
      this.addBallsToGrid(this.preparedBalls);
      return this.preparedBalls = [];
    },
    setActiveBall: function(ball) {
      var _ref;
      if ((_ref = this.activeBall) != null) {
        _ref.setState('usual');
      }
      this.activeBall = ball;
      return ball != null ? ball.setState('active') : void 0;
    },
    setBallPos: function(ball, x, y) {
      /*
      Sets ball position
      Returns true if any line was removed due to this action
      */

      this.grid.remove(ball.gridX, ball.gridY);
      ball.gridX = x;
      ball.gridY = y;
      this.updateBallScreenPos(ball);
      return this.grid.add(x, y, ball);
    },
    getGridPos: function(x, y) {
      x = Math.floor(x / CELL_SIZE);
      y = Math.floor(y / CELL_SIZE);
      if ((0 <= x && x < COL_COUNT) && (0 <= y && y < LINE_COUNT)) {
        return [x, y];
      }
      return null;
    },
    getCellScreenPos: function(x, y) {
      return [x * CELL_SIZE, y * CELL_SIZE];
    },
    updateBallScreenPos: function(ball) {
      var offset, resX, resY, _ref;
      _ref = this.getCellScreenPos(ball.gridX, ball.gridY), resX = _ref[0], resY = _ref[1];
      offset = (CELL_SIZE - BALL_SIZE * ball.scaleFactor) / 2;
      return ball.setPosition(resX + offset, resY + offset);
    },
    onMouseDown: function(b, x, y) {
      var gridPos, worldCoord;
      if (b !== gamvas.mouse.LEFT) {
        return;
      }
      worldCoord = this.camera.toWorld(x, y);
      gridPos = this.getGridPos(worldCoord.x, worldCoord.y);
      if (!gridPos) {
        return;
      }
      return this.gridPosClicks.push(gridPos);
    }
  });

  gamvas.event.addOnLoad(function() {
    gamvas.state.addState(new GameState('game'));
    return gamvas.start('lines-canvas', false);
  });

}).call(this);
