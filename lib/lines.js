// Generated by CoffeeScript 1.6.3
(function() {
  var ActiveBallState, Ball, COL_COUNT, GRID_SIZE, GameState, LINE_COUNT, LINE_DIRECTIONS, MIN_LINE_LENGTH, UsualBallState;

  GRID_SIZE = 26;

  COL_COUNT = 9;

  LINE_COUNT = 9;

  LINE_DIRECTIONS = [[-1, 0], [-1, -1], [0, -1], [1, -1]];

  MIN_LINE_LENGTH = 5;

  ActiveBallState = gamvas.ActorState.extend({
    enter: function() {
      return this.actor.setFile(gamvas.state.getCurrentState().resource.getImage('active_ball.png'));
    }
  });

  UsualBallState = gamvas.ActorState.extend({
    enter: function() {
      return this.actor.setFile(gamvas.state.getCurrentState().resource.getImage('ball.png'));
    }
  });

  Ball = gamvas.Actor.extend({
    create: function(name, x, y) {
      this._super(name, x, y);
      this.addState(new ActiveBallState('active'));
      return this.addState(new UsualBallState('usual'), true);
    }
  });

  GameState = gamvas.State.extend({
    init: function() {
      var i, _i;
      this.gridPosClicks = [];
      this.grid = [];
      for (i = _i = 0; 0 <= COL_COUNT ? _i < COL_COUNT : _i > COL_COUNT; i = 0 <= COL_COUNT ? ++_i : --_i) {
        this.grid.push([]);
      }
      this.addRandomBalls(5);
      return this.camera.setPosition(GRID_SIZE * COL_COUNT / 2, GRID_SIZE * LINE_COUNT / 2);
    },
    addRandomBalls: function(num) {
      var i, _i, _results;
      _results = [];
      for (i = _i = 1; 1 <= num ? _i <= num : _i >= num; i = 1 <= num ? ++_i : --_i) {
        _results.push(this.addRandomBall());
      }
      return _results;
    },
    addRandomBall: function() {
      var freePositions, posIndex, x, y, _ref;
      freePositions = this.getFreeGridPositions();
      posIndex = Math.floor(Math.random() * freePositions.length);
      _ref = freePositions[posIndex], x = _ref[0], y = _ref[1];
      return this.addBall(x, y);
    },
    addBall: function(x, y) {
      var ball, screenX, screenY, _ref;
      _ref = this.getScreenPos(x, y), screenX = _ref[0], screenY = _ref[1];
      ball = new Ball(false, screenX, screenY);
      this.addActor(ball);
      this.grid[x][y] = ball;
      return this.checkLinesRemovalInPosition(x, y);
    },
    draw: function() {
      var pos, x, y, _i, _len, _ref;
      _ref = this.gridPosClicks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pos = _ref[_i];
        x = pos[0], y = pos[1];
        if (this.grid[x][y]) {
          this.setActiveBall(this.grid[x][y]);
        } else if (this.activeBall) {
          this.setBallPos(this.activeBall, x, y);
          this.setActiveBall(null);
          this.addRandomBalls(3);
        }
      }
      return this.gridPosClicks = [];
    },
    setActiveBall: function(ball) {
      var _ref;
      if ((_ref = this.activeBall) != null) {
        _ref.setState('usual');
      }
      this.activeBall = ball;
      return ball != null ? ball.setState('active') : void 0;
    },
    setBallPos: function(ball, x, y) {
      var oldX, oldY, screenX, screenY, _ref, _ref1;
      _ref = this.getGridPos(ball.position.x, ball.position.y), oldX = _ref[0], oldY = _ref[1];
      this.grid[oldX][oldY] = null;
      _ref1 = this.getScreenPos(x, y), screenX = _ref1[0], screenY = _ref1[1];
      ball.setPosition(screenX, screenY);
      this.grid[x][y] = ball;
      return this.checkLinesRemovalInPosition(x, y);
    },
    getFreeGridPositions: function() {
      var i, j, res, _i, _j;
      res = [];
      for (i = _i = 0; 0 <= COL_COUNT ? _i < COL_COUNT : _i > COL_COUNT; i = 0 <= COL_COUNT ? ++_i : --_i) {
        for (j = _j = 0; 0 <= LINE_COUNT ? _j < LINE_COUNT : _j > LINE_COUNT; j = 0 <= LINE_COUNT ? ++_j : --_j) {
          if (!this.grid[i][j]) {
            res.push([i, j]);
          }
        }
      }
      return res;
    },
    getGridPos: function(x, y) {
      x = Math.floor(x / GRID_SIZE);
      y = Math.floor(y / GRID_SIZE);
      if ((0 <= x && x < COL_COUNT) && (0 <= y && y < LINE_COUNT)) {
        return [x, y];
      }
      return null;
    },
    getScreenPos: function(x, y) {
      return [x * GRID_SIZE, y * GRID_SIZE];
    },
    checkLinesRemovalInPosition: function(x, y) {
      var dirCount, dx, dy, endX, endY, line, linesToRemove, oppositeDirCount, startX, startY, _i, _j, _len, _len1, _ref, _results;
      linesToRemove = [];
      for (_i = 0, _len = LINE_DIRECTIONS.length; _i < _len; _i++) {
        _ref = LINE_DIRECTIONS[_i], dx = _ref[0], dy = _ref[1];
        dirCount = this.getMaxBallCount(x, y, dx, dy);
        oppositeDirCount = this.getMaxBallCount(x, y, -dx, -dy);
        if (dirCount + oppositeDirCount + 1 < MIN_LINE_LENGTH) {
          continue;
        }
        startX = x + dx * dirCount;
        startY = y + dy * dirCount;
        endX = x - dx * oppositeDirCount;
        endY = y - dy * oppositeDirCount;
        linesToRemove.push([startX, startY, endX, endY]);
      }
      _results = [];
      for (_j = 0, _len1 = linesToRemove.length; _j < _len1; _j++) {
        line = linesToRemove[_j];
        _results.push(this.removeLine.apply(this, line));
      }
      return _results;
    },
    getDirection: function(start, end) {
      if (start === end) {
        return 0;
      }
      if (end > start) {
        return 1;
      }
      if (end < start) {
        return -1;
      }
    },
    removeLine: function(startX, startY, endX, endY) {
      var curX, curY, dx, dy, _results;
      dx = this.getDirection(startX, endX);
      dy = this.getDirection(startY, endY);
      curX = startX;
      curY = startY;
      this.removeBall(curX, curY);
      _results = [];
      while ((curX !== endX) || (curY !== endY)) {
        curX += dx;
        curY += dy;
        _results.push(this.removeBall(curX, curY));
      }
      return _results;
    },
    removeBall: function(x, y) {
      if (!this.grid[x][y]) {
        return;
      }
      this.removeActor(this.grid[x][y]);
      return this.grid[x][y] = null;
    },
    getMaxBallCount: function(x, y, dx, dy) {
      var res;
      res = 0;
      x += dx;
      y += dy;
      while ((0 <= x && x < COL_COUNT) && (0 <= y && y < LINE_COUNT) && this.grid[x][y]) {
        res++;
        x += dx;
        y += dy;
      }
      return res;
    },
    onMouseDown: function(b, x, y) {
      var gridPos, worldCoord;
      if (b !== gamvas.mouse.LEFT) {
        return;
      }
      worldCoord = this.camera.toWorld(x, y);
      gridPos = this.getGridPos(worldCoord.x, worldCoord.y);
      if (!gridPos) {
        return;
      }
      return this.gridPosClicks.push(gridPos);
    }
  });

  gamvas.event.addOnLoad(function() {
    gamvas.state.addState(new GameState('game'));
    return gamvas.start('lines-canvas', false);
  });

}).call(this);
